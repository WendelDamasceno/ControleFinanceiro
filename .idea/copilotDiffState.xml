<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/CategoriaDAO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/CategoriaDAO.java" />
              <option name="originalContent" value="package com.controlfinanceiro.dao;&#10;&#10;public interface CategoriaDAO {&#10;}&#10;" />
              <option name="updatedContent" value="package com.controlfinanceiro.dao;&#10;&#10;import com.controlfinanceiro.model.Categoria;&#10;import com.controlfinanceiro.exception.DAOException;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface CategoriaDAO {&#10;    &#10;    /**&#10;     * Salva uma nova categoria no banco de dados&#10;     */&#10;    Categoria salvar(Categoria categoria) throws DAOException;&#10;    &#10;    /**&#10;     * Atualiza uma categoria existente&#10;     */&#10;    Categoria atualizar(Categoria categoria) throws DAOException;&#10;    &#10;    /**&#10;     * Remove uma categoria pelo ID&#10;     */&#10;    void deletar(Long id) throws DAOException;&#10;    &#10;    /**&#10;     * Busca uma categoria pelo ID&#10;     */&#10;    Optional&lt;Categoria&gt; buscarPorId(Long id) throws DAOException;&#10;    &#10;    /**&#10;     * Lista todas as categorias ativas&#10;     */&#10;    List&lt;Categoria&gt; listarTodas() throws DAOException;&#10;    &#10;    /**&#10;     * Lista todas as categorias (ativas e inativas)&#10;     */&#10;    List&lt;Categoria&gt; listarTodas(boolean incluirInativas) throws DAOException;&#10;    &#10;    /**&#10;     * Busca categorias por nome&#10;     */&#10;    List&lt;Categoria&gt; buscarPorNome(String nome) throws DAOException;&#10;    &#10;    /**&#10;     * Verifica se existe categoria com o nome informado&#10;     */&#10;    boolean existePorNome(String nome) throws DAOException;&#10;    &#10;    /**&#10;     * Inativa uma categoria (soft delete)&#10;     */&#10;    void inativar(Long id) throws DAOException;&#10;    &#10;    /**&#10;     * Ativa uma categoria&#10;     */&#10;    void ativar(Long id) throws DAOException;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/OrcamentoDAO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/OrcamentoDAO.java" />
              <option name="originalContent" value="package com.controlfinanceiro.dao;&#10;&#10;public interface OrcamentoDAO {&#10;}&#10;" />
              <option name="updatedContent" value="package com.controlfinanceiro.dao;&#10;&#10;import com.controlfinanceiro.model.Orcamento;&#10;import com.controlfinanceiro.exception.DAOException;&#10;import java.math.BigDecimal;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface OrcamentoDAO {&#10;    &#10;    /**&#10;     * Salva um novo orçamento no banco de dados&#10;     */&#10;    Orcamento salvar(Orcamento orcamento) throws DAOException;&#10;    &#10;    /**&#10;     * Atualiza um orçamento existente&#10;     */&#10;    Orcamento atualizar(Orcamento orcamento) throws DAOException;&#10;    &#10;    /**&#10;     * Remove um orçamento pelo ID&#10;     */&#10;    void deletar(Long id) throws DAOException;&#10;    &#10;    /**&#10;     * Busca um orçamento pelo ID&#10;     */&#10;    Optional&lt;Orcamento&gt; buscarPorId(Long id) throws DAOException;&#10;    &#10;    /**&#10;     * Lista todos os orçamentos ativos&#10;     */&#10;    List&lt;Orcamento&gt; listarTodos() throws DAOException;&#10;    &#10;    /**&#10;     * Lista orçamentos por categoria&#10;     */&#10;    List&lt;Orcamento&gt; listarPorCategoria(Long categoriaId) throws DAOException;&#10;    &#10;    /**&#10;     * Lista orçamentos por período (mês/ano)&#10;     */&#10;    List&lt;Orcamento&gt; listarPorPeriodo(int mes, int ano) throws DAOException;&#10;    &#10;    /**&#10;     * Busca orçamento específico por categoria e período&#10;     */&#10;    Optional&lt;Orcamento&gt; buscarPorCategoriaEPeriodo(Long categoriaId, int mes, int ano) throws DAOException;&#10;    &#10;    /**&#10;     * Lista orçamentos por ano&#10;     */&#10;    List&lt;Orcamento&gt; listarPorAno(int ano) throws DAOException;&#10;    &#10;    /**&#10;     * Calcula o total de orçamentos por período&#10;     */&#10;    BigDecimal calcularTotalOrcamentoPeriodo(int mes, int ano) throws DAOException;&#10;    &#10;    /**&#10;     * Verifica se existe orçamento para categoria no período&#10;     */&#10;    boolean existeOrcamentoPorCategoriaEPeriodo(Long categoriaId, int mes, int ano) throws DAOException;&#10;    &#10;    /**&#10;     * Inativa um orçamento (soft delete)&#10;     */&#10;    void inativar(Long id) throws DAOException;&#10;    &#10;    /**&#10;     * Ativa um orçamento&#10;     */&#10;    void ativar(Long id) throws DAOException;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/TransacaoDAO.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/TransacaoDAO.java" />
              <option name="originalContent" value="package com.controlfinanceiro.dao;&#10;&#10;public interface TransacaoDAO {&#10;}&#10;" />
              <option name="updatedContent" value="package com.controlfinanceiro.dao;&#10;&#10;import com.controlfinanceiro.model.Transacao;&#10;import com.controlfinanceiro.model.enums.TipoTransacao;&#10;import com.controlfinanceiro.exception.DAOException;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDate;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public interface TransacaoDAO {&#10;    &#10;    /**&#10;     * Salva uma nova transação no banco de dados&#10;     */&#10;    Transacao salvar(Transacao transacao) throws DAOException;&#10;    &#10;    /**&#10;     * Atualiza uma transação existente&#10;     */&#10;    Transacao atualizar(Transacao transacao) throws DAOException;&#10;    &#10;    /**&#10;     * Remove uma transação pelo ID&#10;     */&#10;    void deletar(Long id) throws DAOException;&#10;    &#10;    /**&#10;     * Busca uma transação pelo ID&#10;     */&#10;    Optional&lt;Transacao&gt; buscarPorId(Long id) throws DAOException;&#10;    &#10;    /**&#10;     * Lista todas as transações ativas&#10;     */&#10;    List&lt;Transacao&gt; listarTodas() throws DAOException;&#10;    &#10;    /**&#10;     * Lista transações por período&#10;     */&#10;    List&lt;Transacao&gt; listarPorPeriodo(LocalDate dataInicio, LocalDate dataFim) throws DAOException;&#10;    &#10;    /**&#10;     * Lista transações por categoria&#10;     */&#10;    List&lt;Transacao&gt; listarPorCategoria(Long categoriaId) throws DAOException;&#10;    &#10;    /**&#10;     * Lista transações por tipo (RECEITA ou DESPESA)&#10;     */&#10;    List&lt;Transacao&gt; listarPorTipo(TipoTransacao tipo) throws DAOException;&#10;    &#10;    /**&#10;     * Lista transações por categoria e período&#10;     */&#10;    List&lt;Transacao&gt; listarPorCategoriaEPeriodo(Long categoriaId, LocalDate dataInicio, LocalDate dataFim) throws DAOException;&#10;    &#10;    /**&#10;     * Calcula o total de receitas em um período&#10;     */&#10;    BigDecimal calcularTotalReceitas(LocalDate dataInicio, LocalDate dataFim) throws DAOException;&#10;    &#10;    /**&#10;     * Calcula o total de despesas em um período&#10;     */&#10;    BigDecimal calcularTotalDespesas(LocalDate dataInicio, LocalDate dataFim) throws DAOException;&#10;    &#10;    /**&#10;     * Calcula o saldo em um período (receitas - despesas)&#10;     */&#10;    BigDecimal calcularSaldo(LocalDate dataInicio, LocalDate dataFim) throws DAOException;&#10;    &#10;    /**&#10;     * Calcula total gasto por categoria em um período&#10;     */&#10;    BigDecimal calcularTotalPorCategoria(Long categoriaId, LocalDate dataInicio, LocalDate dataFim) throws DAOException;&#10;    &#10;    /**&#10;     * Busca transações por descrição&#10;     */&#10;    List&lt;Transacao&gt; buscarPorDescricao(String descricao) throws DAOException;&#10;    &#10;    /**&#10;     * Inativa uma transação (soft delete)&#10;     */&#10;    void inativar(Long id) throws DAOException;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/impl/CategoriaDAOImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/impl/CategoriaDAOImpl.java" />
              <option name="originalContent" value="package com.controlfinanceiro.dao.impl;&#10;&#10;public class CategoriaDAOImpl {&#10;}&#10;" />
              <option name="updatedContent" value="package com.controlfinanceiro.dao.impl;&#10;&#10;import com.controlfinanceiro.dao.CategoriaDAO;&#10;import com.controlfinanceiro.model.Categoria;&#10;import com.controlfinanceiro.exception.DAOException;&#10;import com.controlfinanceiro.util.ConnectionFactory;&#10;&#10;import java.sql.*;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public class CategoriaDAOImpl implements CategoriaDAO {&#10;&#10;    private static final String INSERT_SQL = &#10;        &quot;INSERT INTO categoria (nome, descricao, ativo, data_criacao, data_atualizacao) VALUES (?, ?, ?, ?, ?)&quot;;&#10;    &#10;    private static final String UPDATE_SQL = &#10;        &quot;UPDATE categoria SET nome = ?, descricao = ?, ativo = ?, data_atualizacao = ? WHERE id = ?&quot;;&#10;    &#10;    private static final String DELETE_SQL = &#10;        &quot;DELETE FROM categoria WHERE id = ?&quot;;&#10;    &#10;    private static final String SELECT_BY_ID_SQL = &#10;        &quot;SELECT id, nome, descricao, ativo, data_criacao, data_atualizacao FROM categoria WHERE id = ?&quot;;&#10;    &#10;    private static final String SELECT_ALL_SQL = &#10;        &quot;SELECT id, nome, descricao, ativo, data_criacao, data_atualizacao FROM categoria WHERE ativo = true ORDER BY nome&quot;;&#10;    &#10;    private static final String SELECT_ALL_WITH_INACTIVE_SQL = &#10;        &quot;SELECT id, nome, descricao, ativo, data_criacao, data_atualizacao FROM categoria ORDER BY nome&quot;;&#10;    &#10;    private static final String SELECT_BY_NAME_SQL = &#10;        &quot;SELECT id, nome, descricao, ativo, data_criacao, data_atualizacao FROM categoria WHERE LOWER(nome) LIKE LOWER(?) AND ativo = true&quot;;&#10;    &#10;    private static final String EXISTS_BY_NAME_SQL = &#10;        &quot;SELECT COUNT(*) FROM categoria WHERE LOWER(nome) = LOWER(?) AND ativo = true&quot;;&#10;    &#10;    private static final String INACTIVATE_SQL = &#10;        &quot;UPDATE categoria SET ativo = false, data_atualizacao = ? WHERE id = ?&quot;;&#10;    &#10;    private static final String ACTIVATE_SQL = &#10;        &quot;UPDATE categoria SET ativo = true, data_atualizacao = ? WHERE id = ?&quot;;&#10;&#10;    @Override&#10;    public Categoria salvar(Categoria categoria) throws DAOException {&#10;        if (categoria == null || !categoria.isValid()) {&#10;            throw new DAOException(&quot;Categoria inválida para salvar&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(INSERT_SQL, Statement.RETURN_GENERATED_KEYS)) {&#10;            &#10;            stmt.setString(1, categoria.getNome());&#10;            stmt.setString(2, categoria.getDescricao());&#10;            stmt.setBoolean(3, categoria.isAtivo());&#10;            stmt.setTimestamp(4, Timestamp.valueOf(categoria.getDataCriacao()));&#10;            stmt.setTimestamp(5, Timestamp.valueOf(categoria.getDataAtualizacao()));&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Falha ao salvar categoria&quot;);&#10;            }&#10;&#10;            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {&#10;                if (generatedKeys.next()) {&#10;                    categoria.setId(generatedKeys.getLong(1));&#10;                }&#10;            }&#10;            &#10;            return categoria;&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao salvar categoria: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Categoria atualizar(Categoria categoria) throws DAOException {&#10;        if (categoria == null || categoria.getId() == null || !categoria.isValid()) {&#10;            throw new DAOException(&quot;Categoria inválida para atualizar&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(UPDATE_SQL)) {&#10;            &#10;            categoria.setDataAtualizacao(LocalDateTime.now());&#10;            &#10;            stmt.setString(1, categoria.getNome());&#10;            stmt.setString(2, categoria.getDescricao());&#10;            stmt.setBoolean(3, categoria.isAtivo());&#10;            stmt.setTimestamp(4, Timestamp.valueOf(categoria.getDataAtualizacao()));&#10;            stmt.setLong(5, categoria.getId());&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Categoria não encontrada para atualizar&quot;);&#10;            }&#10;            &#10;            return categoria;&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao atualizar categoria: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void deletar(Long id) throws DAOException {&#10;        if (id == null) {&#10;            throw new DAOException(&quot;ID da categoria não pode ser nulo&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(DELETE_SQL)) {&#10;            &#10;            stmt.setLong(1, id);&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Categoria não encontrada para deletar&quot;);&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao deletar categoria: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;Categoria&gt; buscarPorId(Long id) throws DAOException {&#10;        if (id == null) {&#10;            return Optional.empty();&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_ID_SQL)) {&#10;            &#10;            stmt.setLong(1, id);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return Optional.of(mapResultSetToCategoria(rs));&#10;                }&#10;            }&#10;            &#10;            return Optional.empty();&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao buscar categoria por ID: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Categoria&gt; listarTodas() throws DAOException {&#10;        return listarTodas(false);&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Categoria&gt; listarTodas(boolean incluirInativas) throws DAOException {&#10;        List&lt;Categoria&gt; categorias = new ArrayList&lt;&gt;();&#10;        String sql = incluirInativas ? SELECT_ALL_WITH_INACTIVE_SQL : SELECT_ALL_SQL;&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(sql);&#10;             ResultSet rs = stmt.executeQuery()) {&#10;            &#10;            while (rs.next()) {&#10;                categorias.add(mapResultSetToCategoria(rs));&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao listar categorias: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return categorias;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Categoria&gt; buscarPorNome(String nome) throws DAOException {&#10;        if (nome == null || nome.trim().isEmpty()) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        List&lt;Categoria&gt; categorias = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_NAME_SQL)) {&#10;            &#10;            stmt.setString(1, &quot;%&quot; + nome.trim() + &quot;%&quot;);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    categorias.add(mapResultSetToCategoria(rs));&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao buscar categorias por nome: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return categorias;&#10;    }&#10;&#10;    @Override&#10;    public boolean existePorNome(String nome) throws DAOException {&#10;        if (nome == null || nome.trim().isEmpty()) {&#10;            return false;&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(EXISTS_BY_NAME_SQL)) {&#10;            &#10;            stmt.setString(1, nome.trim());&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getInt(1) &gt; 0;&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao verificar existência de categoria: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public void inativar(Long id) throws DAOException {&#10;        if (id == null) {&#10;            throw new DAOException(&quot;ID da categoria não pode ser nulo&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(INACTIVATE_SQL)) {&#10;            &#10;            stmt.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now()));&#10;            stmt.setLong(2, id);&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Categoria não encontrada para inativar&quot;);&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao inativar categoria: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void ativar(Long id) throws DAOException {&#10;        if (id == null) {&#10;            throw new DAOException(&quot;ID da categoria não pode ser nulo&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(ACTIVATE_SQL)) {&#10;            &#10;            stmt.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now()));&#10;            stmt.setLong(2, id);&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Categoria não encontrada para ativar&quot;);&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao ativar categoria: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    private Categoria mapResultSetToCategoria(ResultSet rs) throws SQLException {&#10;        Categoria categoria = new Categoria();&#10;        categoria.setId(rs.getLong(&quot;id&quot;));&#10;        categoria.setNome(rs.getString(&quot;nome&quot;));&#10;        categoria.setDescricao(rs.getString(&quot;descricao&quot;));&#10;        categoria.setAtivo(rs.getBoolean(&quot;ativo&quot;));&#10;        categoria.setDataCriacao(rs.getTimestamp(&quot;data_criacao&quot;).toLocalDateTime());&#10;        categoria.setDataAtualizacao(rs.getTimestamp(&quot;data_atualizacao&quot;).toLocalDateTime());&#10;        return categoria;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/impl/OrcamentoDAOImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/impl/OrcamentoDAOImpl.java" />
              <option name="originalContent" value="package com.controlfinanceiro.dao.impl;&#10;&#10;public class OrcamentoDAOImpl {&#10;}&#10;" />
              <option name="updatedContent" value="package com.controlfinanceiro.dao.impl;&#10;&#10;import com.controlfinanceiro.dao.OrcamentoDAO;&#10;import com.controlfinanceiro.model.Orcamento;&#10;import com.controlfinanceiro.model.Categoria;&#10;import com.controlfinanceiro.exception.DAOException;&#10;import com.controlfinanceiro.util.ConnectionFactory;&#10;&#10;import java.sql.*;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public class OrcamentoDAOImpl implements OrcamentoDAO {&#10;&#10;    private static final String INSERT_SQL = &#10;        &quot;INSERT INTO orcamento (categoria_id, valor_limite, mes, ano, descricao, ativo, data_criacao, data_atualizacao) &quot; +&#10;        &quot;VALUES (?, ?, ?, ?, ?, ?, ?, ?)&quot;;&#10;    &#10;    private static final String UPDATE_SQL = &#10;        &quot;UPDATE orcamento SET categoria_id = ?, valor_limite = ?, mes = ?, ano = ?, descricao = ?, ativo = ?, data_atualizacao = ? WHERE id = ?&quot;;&#10;    &#10;    private static final String DELETE_SQL = &#10;        &quot;DELETE FROM orcamento WHERE id = ?&quot;;&#10;    &#10;    private static final String SELECT_BY_ID_SQL = &#10;        &quot;SELECT o.id, o.categoria_id, o.valor_limite, o.mes, o.ano, o.descricao, o.ativo, o.data_criacao, o.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM orcamento o LEFT JOIN categoria c ON o.categoria_id = c.id WHERE o.id = ?&quot;;&#10;    &#10;    private static final String SELECT_ALL_SQL = &#10;        &quot;SELECT o.id, o.categoria_id, o.valor_limite, o.mes, o.ano, o.descricao, o.ativo, o.data_criacao, o.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM orcamento o LEFT JOIN categoria c ON o.categoria_id = c.id WHERE o.ativo = true ORDER BY o.ano DESC, o.mes DESC&quot;;&#10;    &#10;    private static final String SELECT_BY_CATEGORIA_SQL = &#10;        &quot;SELECT o.id, o.categoria_id, o.valor_limite, o.mes, o.ano, o.descricao, o.ativo, o.data_criacao, o.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM orcamento o LEFT JOIN categoria c ON o.categoria_id = c.id &quot; +&#10;        &quot;WHERE o.ativo = true AND o.categoria_id = ? ORDER BY o.ano DESC, o.mes DESC&quot;;&#10;    &#10;    private static final String SELECT_BY_PERIOD_SQL = &#10;        &quot;SELECT o.id, o.categoria_id, o.valor_limite, o.mes, o.ano, o.descricao, o.ativo, o.data_criacao, o.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM orcamento o LEFT JOIN categoria c ON o.categoria_id = c.id &quot; +&#10;        &quot;WHERE o.ativo = true AND o.mes = ? AND o.ano = ? ORDER BY c.nome&quot;;&#10;    &#10;    private static final String SELECT_BY_CATEGORIA_PERIOD_SQL = &#10;        &quot;SELECT o.id, o.categoria_id, o.valor_limite, o.mes, o.ano, o.descricao, o.ativo, o.data_criacao, o.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM orcamento o LEFT JOIN categoria c ON o.categoria_id = c.id &quot; +&#10;        &quot;WHERE o.ativo = true AND o.categoria_id = ? AND o.mes = ? AND o.ano = ?&quot;;&#10;    &#10;    private static final String SELECT_BY_ANO_SQL = &#10;        &quot;SELECT o.id, o.categoria_id, o.valor_limite, o.mes, o.ano, o.descricao, o.ativo, o.data_criacao, o.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM orcamento o LEFT JOIN categoria c ON o.categoria_id = c.id &quot; +&#10;        &quot;WHERE o.ativo = true AND o.ano = ? ORDER BY o.mes, c.nome&quot;;&#10;    &#10;    private static final String SUM_BY_PERIOD_SQL = &#10;        &quot;SELECT COALESCE(SUM(valor_limite), 0) FROM orcamento WHERE ativo = true AND mes = ? AND ano = ?&quot;;&#10;    &#10;    private static final String EXISTS_BY_CATEGORIA_PERIOD_SQL = &#10;        &quot;SELECT COUNT(*) FROM orcamento WHERE categoria_id = ? AND mes = ? AND ano = ? AND ativo = true&quot;;&#10;    &#10;    private static final String INACTIVATE_SQL = &#10;        &quot;UPDATE orcamento SET ativo = false, data_atualizacao = ? WHERE id = ?&quot;;&#10;    &#10;    private static final String ACTIVATE_SQL = &#10;        &quot;UPDATE orcamento SET ativo = true, data_atualizacao = ? WHERE id = ?&quot;;&#10;&#10;    @Override&#10;    public Orcamento salvar(Orcamento orcamento) throws DAOException {&#10;        if (orcamento == null || !orcamento.isValid()) {&#10;            throw new DAOException(&quot;Orçamento inválido para salvar&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(INSERT_SQL, Statement.RETURN_GENERATED_KEYS)) {&#10;            &#10;            stmt.setLong(1, orcamento.getCategoriaId());&#10;            stmt.setBigDecimal(2, orcamento.getValorLimite());&#10;            stmt.setInt(3, orcamento.getMes());&#10;            stmt.setInt(4, orcamento.getAno());&#10;            stmt.setString(5, orcamento.getDescricao());&#10;            stmt.setBoolean(6, orcamento.isAtivo());&#10;            stmt.setTimestamp(7, Timestamp.valueOf(orcamento.getDataCriacao()));&#10;            stmt.setTimestamp(8, Timestamp.valueOf(orcamento.getDataAtualizacao()));&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Falha ao salvar orçamento&quot;);&#10;            }&#10;&#10;            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {&#10;                if (generatedKeys.next()) {&#10;                    orcamento.setId(generatedKeys.getLong(1));&#10;                }&#10;            }&#10;            &#10;            return orcamento;&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao salvar orçamento: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Orcamento atualizar(Orcamento orcamento) throws DAOException {&#10;        if (orcamento == null || orcamento.getId() == null || !orcamento.isValid()) {&#10;            throw new DAOException(&quot;Orçamento inválido para atualizar&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(UPDATE_SQL)) {&#10;            &#10;            orcamento.setDataAtualizacao(LocalDateTime.now());&#10;            &#10;            stmt.setLong(1, orcamento.getCategoriaId());&#10;            stmt.setBigDecimal(2, orcamento.getValorLimite());&#10;            stmt.setInt(3, orcamento.getMes());&#10;            stmt.setInt(4, orcamento.getAno());&#10;            stmt.setString(5, orcamento.getDescricao());&#10;            stmt.setBoolean(6, orcamento.isAtivo());&#10;            stmt.setTimestamp(7, Timestamp.valueOf(orcamento.getDataAtualizacao()));&#10;            stmt.setLong(8, orcamento.getId());&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Orçamento não encontrado para atualizar&quot;);&#10;            }&#10;            &#10;            return orcamento;&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao atualizar orçamento: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void deletar(Long id) throws DAOException {&#10;        if (id == null) {&#10;            throw new DAOException(&quot;ID do orçamento não pode ser nulo&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(DELETE_SQL)) {&#10;            &#10;            stmt.setLong(1, id);&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Orçamento não encontrado para deletar&quot;);&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao deletar orçamento: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;Orcamento&gt; buscarPorId(Long id) throws DAOException {&#10;        if (id == null) {&#10;            return Optional.empty();&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_ID_SQL)) {&#10;            &#10;            stmt.setLong(1, id);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return Optional.of(mapResultSetToOrcamento(rs));&#10;                }&#10;            }&#10;            &#10;            return Optional.empty();&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao buscar orçamento por ID: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Orcamento&gt; listarTodos() throws DAOException {&#10;        List&lt;Orcamento&gt; orcamentos = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_ALL_SQL);&#10;             ResultSet rs = stmt.executeQuery()) {&#10;            &#10;            while (rs.next()) {&#10;                orcamentos.add(mapResultSetToOrcamento(rs));&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao listar orçamentos: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return orcamentos;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Orcamento&gt; listarPorCategoria(Long categoriaId) throws DAOException {&#10;        if (categoriaId == null) {&#10;            throw new DAOException(&quot;ID da categoria não pode ser nulo&quot;);&#10;        }&#10;&#10;        List&lt;Orcamento&gt; orcamentos = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_CATEGORIA_SQL)) {&#10;            &#10;            stmt.setLong(1, categoriaId);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    orcamentos.add(mapResultSetToOrcamento(rs));&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao listar orçamentos por categoria: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return orcamentos;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Orcamento&gt; listarPorPeriodo(int mes, int ano) throws DAOException {&#10;        List&lt;Orcamento&gt; orcamentos = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_PERIOD_SQL)) {&#10;            &#10;            stmt.setInt(1, mes);&#10;            stmt.setInt(2, ano);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    orcamentos.add(mapResultSetToOrcamento(rs));&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao listar orçamentos por período: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return orcamentos;&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;Orcamento&gt; buscarPorCategoriaEPeriodo(Long categoriaId, int mes, int ano) throws DAOException {&#10;        if (categoriaId == null) {&#10;            throw new DAOException(&quot;ID da categoria não pode ser nulo&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_CATEGORIA_PERIOD_SQL)) {&#10;            &#10;            stmt.setLong(1, categoriaId);&#10;            stmt.setInt(2, mes);&#10;            stmt.setInt(3, ano);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return Optional.of(mapResultSetToOrcamento(rs));&#10;                }&#10;            }&#10;            &#10;            return Optional.empty();&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao buscar orçamento por categoria e período: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Orcamento&gt; listarPorAno(int ano) throws DAOException {&#10;        List&lt;Orcamento&gt; orcamentos = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_ANO_SQL)) {&#10;            &#10;            stmt.setInt(1, ano);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    orcamentos.add(mapResultSetToOrcamento(rs));&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao listar orçamentos por ano: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return orcamentos;&#10;    }&#10;&#10;    @Override&#10;    public BigDecimal calcularTotalOrcamentoPeriodo(int mes, int ano) throws DAOException {&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SUM_BY_PERIOD_SQL)) {&#10;            &#10;            stmt.setInt(1, mes);&#10;            stmt.setInt(2, ano);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getBigDecimal(1);&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao calcular total de orçamento: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return BigDecimal.ZERO;&#10;    }&#10;&#10;    @Override&#10;    public boolean existeOrcamentoPorCategoriaEPeriodo(Long categoriaId, int mes, int ano) throws DAOException {&#10;        if (categoriaId == null) {&#10;            return false;&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(EXISTS_BY_CATEGORIA_PERIOD_SQL)) {&#10;            &#10;            stmt.setLong(1, categoriaId);&#10;            stmt.setInt(2, mes);&#10;            stmt.setInt(3, ano);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getInt(1) &gt; 0;&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao verificar existência de orçamento: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return false;&#10;    }&#10;&#10;    @Override&#10;    public void inativar(Long id) throws DAOException {&#10;        if (id == null) {&#10;            throw new DAOException(&quot;ID do orçamento não pode ser nulo&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(INACTIVATE_SQL)) {&#10;            &#10;            stmt.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now()));&#10;            stmt.setLong(2, id);&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Orçamento não encontrado para inativar&quot;);&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao inativar orçamento: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void ativar(Long id) throws DAOException {&#10;        if (id == null) {&#10;            throw new DAOException(&quot;ID do orçamento não pode ser nulo&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(ACTIVATE_SQL)) {&#10;            &#10;            stmt.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now()));&#10;            stmt.setLong(2, id);&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Orçamento não encontrado para ativar&quot;);&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao ativar orçamento: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    private Orcamento mapResultSetToOrcamento(ResultSet rs) throws SQLException {&#10;        Orcamento orcamento = new Orcamento();&#10;        orcamento.setId(rs.getLong(&quot;id&quot;));&#10;        orcamento.setCategoriaId(rs.getLong(&quot;categoria_id&quot;));&#10;        orcamento.setValorLimite(rs.getBigDecimal(&quot;valor_limite&quot;));&#10;        orcamento.setMes(rs.getInt(&quot;mes&quot;));&#10;        orcamento.setAno(rs.getInt(&quot;ano&quot;));&#10;        orcamento.setDescricao(rs.getString(&quot;descricao&quot;));&#10;        orcamento.setAtivo(rs.getBoolean(&quot;ativo&quot;));&#10;        orcamento.setDataCriacao(rs.getTimestamp(&quot;data_criacao&quot;).toLocalDateTime());&#10;        orcamento.setDataAtualizacao(rs.getTimestamp(&quot;data_atualizacao&quot;).toLocalDateTime());&#10;        &#10;        // Mapear categoria se existir&#10;        if (rs.getString(&quot;categoria_nome&quot;) != null) {&#10;            Categoria categoria = new Categoria();&#10;            categoria.setId(rs.getLong(&quot;categoria_id&quot;));&#10;            categoria.setNome(rs.getString(&quot;categoria_nome&quot;));&#10;            categoria.setDescricao(rs.getString(&quot;categoria_descricao&quot;));&#10;            orcamento.setCategoria(categoria);&#10;        }&#10;        &#10;        return orcamento;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/impl/TransacaoDAOImpl.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/dao/impl/TransacaoDAOImpl.java" />
              <option name="originalContent" value="package com.controlfinanceiro.dao.impl;&#10;&#10;public class TransacaoDAOImpl {&#10;}&#10;" />
              <option name="updatedContent" value="package com.controlfinanceiro.dao.impl;&#10;&#10;import com.controlfinanceiro.dao.TransacaoDAO;&#10;import com.controlfinanceiro.model.Transacao;&#10;import com.controlfinanceiro.model.Categoria;&#10;import com.controlfinanceiro.model.enums.TipoTransacao;&#10;import com.controlfinanceiro.exception.DAOException;&#10;import com.controlfinanceiro.util.ConnectionFactory;&#10;&#10;import java.sql.*;&#10;import java.math.BigDecimal;&#10;import java.time.LocalDate;&#10;import java.time.LocalDateTime;&#10;import java.util.ArrayList;&#10;import java.util.List;&#10;import java.util.Optional;&#10;&#10;public class TransacaoDAOImpl implements TransacaoDAO {&#10;&#10;    private static final String INSERT_SQL = &#10;        &quot;INSERT INTO transacao (descricao, valor, data_transacao, tipo, categoria_id, observacao, ativo, data_criacao, data_atualizacao) &quot; +&#10;        &quot;VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;;&#10;    &#10;    private static final String UPDATE_SQL = &#10;        &quot;UPDATE transacao SET descricao = ?, valor = ?, data_transacao = ?, tipo = ?, categoria_id = ?, observacao = ?, ativo = ?, data_atualizacao = ? WHERE id = ?&quot;;&#10;    &#10;    private static final String DELETE_SQL = &#10;        &quot;DELETE FROM transacao WHERE id = ?&quot;;&#10;    &#10;    private static final String SELECT_BY_ID_SQL = &#10;        &quot;SELECT t.id, t.descricao, t.valor, t.data_transacao, t.tipo, t.categoria_id, t.observacao, t.ativo, t.data_criacao, t.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM transacao t LEFT JOIN categoria c ON t.categoria_id = c.id WHERE t.id = ?&quot;;&#10;    &#10;    private static final String SELECT_ALL_SQL = &#10;        &quot;SELECT t.id, t.descricao, t.valor, t.data_transacao, t.tipo, t.categoria_id, t.observacao, t.ativo, t.data_criacao, t.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM transacao t LEFT JOIN categoria c ON t.categoria_id = c.id WHERE t.ativo = true ORDER BY t.data_transacao DESC&quot;;&#10;    &#10;    private static final String SELECT_BY_PERIOD_SQL = &#10;        &quot;SELECT t.id, t.descricao, t.valor, t.data_transacao, t.tipo, t.categoria_id, t.observacao, t.ativo, t.data_criacao, t.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM transacao t LEFT JOIN categoria c ON t.categoria_id = c.id &quot; +&#10;        &quot;WHERE t.ativo = true AND t.data_transacao BETWEEN ? AND ? ORDER BY t.data_transacao DESC&quot;;&#10;    &#10;    private static final String SELECT_BY_CATEGORIA_SQL = &#10;        &quot;SELECT t.id, t.descricao, t.valor, t.data_transacao, t.tipo, t.categoria_id, t.observacao, t.ativo, t.data_criacao, t.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM transacao t LEFT JOIN categoria c ON t.categoria_id = c.id &quot; +&#10;        &quot;WHERE t.ativo = true AND t.categoria_id = ? ORDER BY t.data_transacao DESC&quot;;&#10;    &#10;    private static final String SELECT_BY_TIPO_SQL = &#10;        &quot;SELECT t.id, t.descricao, t.valor, t.data_transacao, t.tipo, t.categoria_id, t.observacao, t.ativo, t.data_criacao, t.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM transacao t LEFT JOIN categoria c ON t.categoria_id = c.id &quot; +&#10;        &quot;WHERE t.ativo = true AND t.tipo = ? ORDER BY t.data_transacao DESC&quot;;&#10;    &#10;    private static final String SELECT_BY_CATEGORIA_PERIOD_SQL = &#10;        &quot;SELECT t.id, t.descricao, t.valor, t.data_transacao, t.tipo, t.categoria_id, t.observacao, t.ativo, t.data_criacao, t.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM transacao t LEFT JOIN categoria c ON t.categoria_id = c.id &quot; +&#10;        &quot;WHERE t.ativo = true AND t.categoria_id = ? AND t.data_transacao BETWEEN ? AND ? ORDER BY t.data_transacao DESC&quot;;&#10;    &#10;    private static final String SUM_RECEITAS_SQL = &#10;        &quot;SELECT COALESCE(SUM(valor), 0) FROM transacao WHERE ativo = true AND tipo = 'RECEITA' AND data_transacao BETWEEN ? AND ?&quot;;&#10;    &#10;    private static final String SUM_DESPESAS_SQL = &#10;        &quot;SELECT COALESCE(SUM(valor), 0) FROM transacao WHERE ativo = true AND tipo = 'DESPESA' AND data_transacao BETWEEN ? AND ?&quot;;&#10;    &#10;    private static final String SUM_BY_CATEGORIA_SQL = &#10;        &quot;SELECT COALESCE(SUM(valor), 0) FROM transacao WHERE ativo = true AND categoria_id = ? AND data_transacao BETWEEN ? AND ?&quot;;&#10;    &#10;    private static final String SELECT_BY_DESCRICAO_SQL = &#10;        &quot;SELECT t.id, t.descricao, t.valor, t.data_transacao, t.tipo, t.categoria_id, t.observacao, t.ativo, t.data_criacao, t.data_atualizacao, &quot; +&#10;        &quot;c.nome as categoria_nome, c.descricao as categoria_descricao &quot; +&#10;        &quot;FROM transacao t LEFT JOIN categoria c ON t.categoria_id = c.id &quot; +&#10;        &quot;WHERE t.ativo = true AND LOWER(t.descricao) LIKE LOWER(?) ORDER BY t.data_transacao DESC&quot;;&#10;    &#10;    private static final String INACTIVATE_SQL = &#10;        &quot;UPDATE transacao SET ativo = false, data_atualizacao = ? WHERE id = ?&quot;;&#10;&#10;    @Override&#10;    public Transacao salvar(Transacao transacao) throws DAOException {&#10;        if (transacao == null || !transacao.isValid()) {&#10;            throw new DAOException(&quot;Transação inválida para salvar&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(INSERT_SQL, Statement.RETURN_GENERATED_KEYS)) {&#10;            &#10;            stmt.setString(1, transacao.getDescricao());&#10;            stmt.setBigDecimal(2, transacao.getValor());&#10;            stmt.setDate(3, Date.valueOf(transacao.getDataTransacao()));&#10;            stmt.setString(4, transacao.getTipo().name());&#10;            stmt.setObject(5, transacao.getCategoriaId());&#10;            stmt.setString(6, transacao.getObservacao());&#10;            stmt.setBoolean(7, transacao.isAtivo());&#10;            stmt.setTimestamp(8, Timestamp.valueOf(transacao.getDataCriacao()));&#10;            stmt.setTimestamp(9, Timestamp.valueOf(transacao.getDataAtualizacao()));&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Falha ao salvar transação&quot;);&#10;            }&#10;&#10;            try (ResultSet generatedKeys = stmt.getGeneratedKeys()) {&#10;                if (generatedKeys.next()) {&#10;                    transacao.setId(generatedKeys.getLong(1));&#10;                }&#10;            }&#10;            &#10;            return transacao;&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao salvar transação: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Transacao atualizar(Transacao transacao) throws DAOException {&#10;        if (transacao == null || transacao.getId() == null || !transacao.isValid()) {&#10;            throw new DAOException(&quot;Transação inválida para atualizar&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(UPDATE_SQL)) {&#10;            &#10;            transacao.setDataAtualizacao(LocalDateTime.now());&#10;            &#10;            stmt.setString(1, transacao.getDescricao());&#10;            stmt.setBigDecimal(2, transacao.getValor());&#10;            stmt.setDate(3, Date.valueOf(transacao.getDataTransacao()));&#10;            stmt.setString(4, transacao.getTipo().name());&#10;            stmt.setObject(5, transacao.getCategoriaId());&#10;            stmt.setString(6, transacao.getObservacao());&#10;            stmt.setBoolean(7, transacao.isAtivo());&#10;            stmt.setTimestamp(8, Timestamp.valueOf(transacao.getDataAtualizacao()));&#10;            stmt.setLong(9, transacao.getId());&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Transação não encontrada para atualizar&quot;);&#10;            }&#10;            &#10;            return transacao;&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao atualizar transação: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public void deletar(Long id) throws DAOException {&#10;        if (id == null) {&#10;            throw new DAOException(&quot;ID da transação não pode ser nulo&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(DELETE_SQL)) {&#10;            &#10;            stmt.setLong(1, id);&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Transação não encontrada para deletar&quot;);&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao deletar transação: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public Optional&lt;Transacao&gt; buscarPorId(Long id) throws DAOException {&#10;        if (id == null) {&#10;            return Optional.empty();&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_ID_SQL)) {&#10;            &#10;            stmt.setLong(1, id);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return Optional.of(mapResultSetToTransacao(rs));&#10;                }&#10;            }&#10;            &#10;            return Optional.empty();&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao buscar transação por ID: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Transacao&gt; listarTodas() throws DAOException {&#10;        List&lt;Transacao&gt; transacoes = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_ALL_SQL);&#10;             ResultSet rs = stmt.executeQuery()) {&#10;            &#10;            while (rs.next()) {&#10;                transacoes.add(mapResultSetToTransacao(rs));&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao listar transações: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return transacoes;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Transacao&gt; listarPorPeriodo(LocalDate dataInicio, LocalDate dataFim) throws DAOException {&#10;        if (dataInicio == null || dataFim == null) {&#10;            throw new DAOException(&quot;Datas de início e fim não podem ser nulas&quot;);&#10;        }&#10;&#10;        List&lt;Transacao&gt; transacoes = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_PERIOD_SQL)) {&#10;            &#10;            stmt.setDate(1, Date.valueOf(dataInicio));&#10;            stmt.setDate(2, Date.valueOf(dataFim));&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    transacoes.add(mapResultSetToTransacao(rs));&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao listar transações por período: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return transacoes;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Transacao&gt; listarPorCategoria(Long categoriaId) throws DAOException {&#10;        if (categoriaId == null) {&#10;            throw new DAOException(&quot;ID da categoria não pode ser nulo&quot;);&#10;        }&#10;&#10;        List&lt;Transacao&gt; transacoes = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_CATEGORIA_SQL)) {&#10;            &#10;            stmt.setLong(1, categoriaId);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    transacoes.add(mapResultSetToTransacao(rs));&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao listar transações por categoria: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return transacoes;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Transacao&gt; listarPorTipo(TipoTransacao tipo) throws DAOException {&#10;        if (tipo == null) {&#10;            throw new DAOException(&quot;Tipo da transação não pode ser nulo&quot;);&#10;        }&#10;&#10;        List&lt;Transacao&gt; transacoes = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_TIPO_SQL)) {&#10;            &#10;            stmt.setString(1, tipo.name());&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    transacoes.add(mapResultSetToTransacao(rs));&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao listar transações por tipo: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return transacoes;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Transacao&gt; listarPorCategoriaEPeriodo(Long categoriaId, LocalDate dataInicio, LocalDate dataFim) throws DAOException {&#10;        if (categoriaId == null || dataInicio == null || dataFim == null) {&#10;            throw new DAOException(&quot;Categoria e datas não podem ser nulas&quot;);&#10;        }&#10;&#10;        List&lt;Transacao&gt; transacoes = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_CATEGORIA_PERIOD_SQL)) {&#10;            &#10;            stmt.setLong(1, categoriaId);&#10;            stmt.setDate(2, Date.valueOf(dataInicio));&#10;            stmt.setDate(3, Date.valueOf(dataFim));&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    transacoes.add(mapResultSetToTransacao(rs));&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao listar transações por categoria e período: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return transacoes;&#10;    }&#10;&#10;    @Override&#10;    public BigDecimal calcularTotalReceitas(LocalDate dataInicio, LocalDate dataFim) throws DAOException {&#10;        if (dataInicio == null || dataFim == null) {&#10;            throw new DAOException(&quot;Datas de início e fim não podem ser nulas&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SUM_RECEITAS_SQL)) {&#10;            &#10;            stmt.setDate(1, Date.valueOf(dataInicio));&#10;            stmt.setDate(2, Date.valueOf(dataFim));&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getBigDecimal(1);&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao calcular total de receitas: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return BigDecimal.ZERO;&#10;    }&#10;&#10;    @Override&#10;    public BigDecimal calcularTotalDespesas(LocalDate dataInicio, LocalDate dataFim) throws DAOException {&#10;        if (dataInicio == null || dataFim == null) {&#10;            throw new DAOException(&quot;Datas de início e fim não podem ser nulas&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SUM_DESPESAS_SQL)) {&#10;            &#10;            stmt.setDate(1, Date.valueOf(dataInicio));&#10;            stmt.setDate(2, Date.valueOf(dataFim));&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getBigDecimal(1);&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao calcular total de despesas: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return BigDecimal.ZERO;&#10;    }&#10;&#10;    @Override&#10;    public BigDecimal calcularSaldo(LocalDate dataInicio, LocalDate dataFim) throws DAOException {&#10;        BigDecimal receitas = calcularTotalReceitas(dataInicio, dataFim);&#10;        BigDecimal despesas = calcularTotalDespesas(dataInicio, dataFim);&#10;        return receitas.subtract(despesas);&#10;    }&#10;&#10;    @Override&#10;    public BigDecimal calcularTotalPorCategoria(Long categoriaId, LocalDate dataInicio, LocalDate dataFim) throws DAOException {&#10;        if (categoriaId == null || dataInicio == null || dataFim == null) {&#10;            throw new DAOException(&quot;Categoria e datas não podem ser nulas&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SUM_BY_CATEGORIA_SQL)) {&#10;            &#10;            stmt.setLong(1, categoriaId);&#10;            stmt.setDate(2, Date.valueOf(dataInicio));&#10;            stmt.setDate(3, Date.valueOf(dataFim));&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                if (rs.next()) {&#10;                    return rs.getBigDecimal(1);&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao calcular total por categoria: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return BigDecimal.ZERO;&#10;    }&#10;&#10;    @Override&#10;    public List&lt;Transacao&gt; buscarPorDescricao(String descricao) throws DAOException {&#10;        if (descricao == null || descricao.trim().isEmpty()) {&#10;            return new ArrayList&lt;&gt;();&#10;        }&#10;&#10;        List&lt;Transacao&gt; transacoes = new ArrayList&lt;&gt;();&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(SELECT_BY_DESCRICAO_SQL)) {&#10;            &#10;            stmt.setString(1, &quot;%&quot; + descricao.trim() + &quot;%&quot;);&#10;            &#10;            try (ResultSet rs = stmt.executeQuery()) {&#10;                while (rs.next()) {&#10;                    transacoes.add(mapResultSetToTransacao(rs));&#10;                }&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao buscar transações por descrição: &quot; + e.getMessage(), e);&#10;        }&#10;        &#10;        return transacoes;&#10;    }&#10;&#10;    @Override&#10;    public void inativar(Long id) throws DAOException {&#10;        if (id == null) {&#10;            throw new DAOException(&quot;ID da transação não pode ser nulo&quot;);&#10;        }&#10;&#10;        try (Connection conn = ConnectionFactory.getConnection();&#10;             PreparedStatement stmt = conn.prepareStatement(INACTIVATE_SQL)) {&#10;            &#10;            stmt.setTimestamp(1, Timestamp.valueOf(LocalDateTime.now()));&#10;            stmt.setLong(2, id);&#10;            &#10;            int rowsAffected = stmt.executeUpdate();&#10;            if (rowsAffected == 0) {&#10;                throw new DAOException(&quot;Transação não encontrada para inativar&quot;);&#10;            }&#10;            &#10;        } catch (SQLException e) {&#10;            throw new DAOException(&quot;Erro ao inativar transação: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    private Transacao mapResultSetToTransacao(ResultSet rs) throws SQLException {&#10;        Transacao transacao = new Transacao();&#10;        transacao.setId(rs.getLong(&quot;id&quot;));&#10;        transacao.setDescricao(rs.getString(&quot;descricao&quot;));&#10;        transacao.setValor(rs.getBigDecimal(&quot;valor&quot;));&#10;        transacao.setDataTransacao(rs.getDate(&quot;data_transacao&quot;).toLocalDate());&#10;        transacao.setTipo(TipoTransacao.valueOf(rs.getString(&quot;tipo&quot;)));&#10;        &#10;        Long categoriaId = rs.getObject(&quot;categoria_id&quot;, Long.class);&#10;        transacao.setCategoriaId(categoriaId);&#10;        &#10;        // Mapear categoria se existir&#10;        if (categoriaId != null &amp;&amp; rs.getString(&quot;categoria_nome&quot;) != null) {&#10;            Categoria categoria = new Categoria();&#10;            categoria.setId(categoriaId);&#10;            categoria.setNome(rs.getString(&quot;categoria_nome&quot;));&#10;            categoria.setDescricao(rs.getString(&quot;categoria_descricao&quot;));&#10;            transacao.setCategoria(categoria);&#10;        }&#10;        &#10;        transacao.setObservacao(rs.getString(&quot;observacao&quot;));&#10;        transacao.setAtivo(rs.getBoolean(&quot;ativo&quot;));&#10;        transacao.setDataCriacao(rs.getTimestamp(&quot;data_criacao&quot;).toLocalDateTime());&#10;        transacao.setDataAtualizacao(rs.getTimestamp(&quot;data_atualizacao&quot;).toLocalDateTime());&#10;        &#10;        return transacao;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/util/ConnectionFactory.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/controlfinanceiro/util/ConnectionFactory.java" />
              <option name="originalContent" value="package com.controlfinanceiro.util;&#10;&#10;public class ConnectionFactory {&#10;}&#10;" />
              <option name="updatedContent" value="package com.controlfinanceiro.util;&#10;&#10;import java.io.IOException;&#10;import java.io.InputStream;&#10;import java.sql.Connection;&#10;import java.sql.DriverManager;&#10;import java.sql.SQLException;&#10;import java.util.Properties;&#10;&#10;/**&#10; * Factory para criação de conexões com o banco de dados&#10; */&#10;public class ConnectionFactory {&#10;    &#10;    private static final String PROPERTIES_FILE = &quot;/database.properties&quot;;&#10;    private static Properties properties;&#10;    &#10;    static {&#10;        loadProperties();&#10;    }&#10;    &#10;    /**&#10;     * Carrega as propriedades do banco de dados&#10;     */&#10;    private static void loadProperties() {&#10;        properties = new Properties();&#10;        try (InputStream input = ConnectionFactory.class.getResourceAsStream(PROPERTIES_FILE)) {&#10;            if (input == null) {&#10;                throw new RuntimeException(&quot;Arquivo de propriedades do banco não encontrado: &quot; + PROPERTIES_FILE);&#10;            }&#10;            properties.load(input);&#10;        } catch (IOException e) {&#10;            throw new RuntimeException(&quot;Erro ao carregar propriedades do banco de dados&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtém uma nova conexão com o banco de dados&#10;     * @return Connection configurada&#10;     * @throws SQLException se houver erro na conexão&#10;     */&#10;    public static Connection getConnection() throws SQLException {&#10;        try {&#10;            String url = properties.getProperty(&quot;database.url&quot;);&#10;            String username = properties.getProperty(&quot;database.username&quot;);&#10;            String password = properties.getProperty(&quot;database.password&quot;);&#10;            String driver = properties.getProperty(&quot;database.driver&quot;);&#10;            &#10;            if (url == null || username == null || password == null || driver == null) {&#10;                throw new SQLException(&quot;Propriedades do banco de dados não configuradas corretamente&quot;);&#10;            }&#10;            &#10;            // Carrega o driver JDBC&#10;            Class.forName(driver);&#10;            &#10;            return DriverManager.getConnection(url, username, password);&#10;            &#10;        } catch (ClassNotFoundException e) {&#10;            throw new SQLException(&quot;Driver JDBC não encontrado&quot;, e);&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Testa a conexão com o banco de dados&#10;     * @return true se a conexão foi bem-sucedida, false caso contrário&#10;     */&#10;    public static boolean testConnection() {&#10;        try (Connection conn = getConnection()) {&#10;            return conn != null &amp;&amp; !conn.isClosed();&#10;        } catch (SQLException e) {&#10;            System.err.println(&quot;Erro ao testar conexão: &quot; + e.getMessage());&#10;            return false;&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtém uma propriedade específica do banco de dados&#10;     * @param key chave da propriedade&#10;     * @return valor da propriedade ou null se não encontrada&#10;     */&#10;    public static String getProperty(String key) {&#10;        return properties.getProperty(key);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/resources/database.properties">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/resources/database.properties" />
              <option name="updatedContent" value="# Configurações do Banco de Dados H2&#10;database.driver=org.h2.Driver&#10;database.url=jdbc:h2:~/controlefinanceiro;DB_CLOSE_ON_EXIT=FALSE;AUTO_RECONNECT=TRUE&#10;database.username=sa&#10;database.password=&#10;&#10;# Configurações alternativas para MySQL (comentadas)&#10;# database.driver=com.mysql.cj.jdbc.Driver&#10;# database.url=jdbc:mysql://localhost:3306/controle_financeiro?useSSL=false&amp;serverTimezone=UTC&#10;# database.username=root&#10;# database.password=senha&#10;&#10;# Configurações alternativas para PostgreSQL (comentadas)&#10;# database.driver=org.postgresql.Driver&#10;# database.url=jdbc:postgresql://localhost:5432/controle_financeiro&#10;# database.username=postgres&#10;# database.password=senha" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>